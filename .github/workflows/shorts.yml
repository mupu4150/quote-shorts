name: 'build-shorts-pattern2'

on:
  repository_dispatch:
    types: [quote-shorts]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            ffmpeg jq python3 python3-pip \
            open-jtalk open-jtalk-mecab-naist-jdic \
            hts-voice-nitech-jp-atr503-m001 \
            fonts-noto-cjk

      - name: Extract payload
        run: |
          jq -r '.client_payload.segments_json' "$GITHUB_EVENT_PATH" > segments.json
          jq -r '.client_payload.narration' "$GITHUB_EVENT_PATH" > narration.txt
          jq -r '.client_payload.bg_urls // empty | .[]' "$GITHUB_EVENT_PATH" > bg_urls.txt || true
          jq -r '.client_payload.bg_switch_at // empty | @json' "$GITHUB_EVENT_PATH" > bg_switch_at.json || echo "[]" > bg_switch_at.json
          VOICE_RATE=$(jq -r '.client_payload.voice_rate // 1.08' "$GITHUB_EVENT_PATH")
          echo "VOICE_RATE=$VOICE_RATE" >> $GITHUB_ENV

      - name: Resolve OpenJTalk paths
        id: jtalk
        run: |
          DIC=$(dpkg -L open-jtalk-mecab-naist-jdic | grep '/naist-jdic$' | head -n1)
          VOICE=$(dpkg -L hts-voice-nitech-jp-atr503-m001 | grep '\.htsvoice$' | head -n1)
          echo "dic=$DIC" >> $GITHUB_OUTPUT
          echo "voice=$VOICE" >> $GITHUB_OUTPUT
          test -n "$DIC" && test -n "$VOICE" || (echo "OpenJTalk dic/voice not found"; exit 1)

      - name: TTS (OpenJTalk → voice.wav)
        env:
          DIC: ${{ steps.jtalk.outputs.dic }}
          VOICE: ${{ steps.jtalk.outputs.voice }}
          RATE: ${{ env.VOICE_RATE }}
        run: |
          # 手動Runでpayloadが空の時の保険
          if ! [ -s narration.txt ]; then echo "テスト音声です。これは同期確認用のサンプルです。" > narration.txt; fi
          open_jtalk -x "$DIC" -m "$VOICE" -r "${RATE:-1.08}" -ow voice.wav < narration.txt


      - name: Measure audio duration
        id: dur
        run: |
          D=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 voice.wav)
          printf "duration=%.3f\n" "$D" >> $GITHUB_OUTPUT

      - name: Build SRT aligned to audio (proportional)
        env:
          AUDIO_DUR: ${{ steps.dur.outputs.duration }}
        run: |
          python3 - << 'PY'
          import json, os
          segs = json.load(open("segments.json","r",encoding="utf-8"))
          total = float(os.environ.get("AUDIO_DUR","50"))
          if total < 5: total = 50.0
          def weight(t):
              t = "".join(ch for ch in str(t) if ch.strip())
              return max(1, len(t))
          W = [weight(s.get("text","")) for s in segs]
          S = sum(W) or 1
          lens = [total*w/S for w in W]
          starts=[0.0]
          for L in lens[:-1]:
              starts.append(starts[-1]+L)
          def ts(x):
              x=max(0.0,x)
              h=int(x//3600); m=int((x%3600)//60); s=int(x%60); ms=int((x*1000)%1000)
              return f"{h:02d}:{m:02d}:{s:02d},{ms:03d}"
          lines=[]
          for i, s in enumerate(segs,1):
              st=starts[i-1]; en=(starts[i] if i<len(starts) else total)
              text=str(s.get("text","")).strip()
              if not text: continue
              lines += [str(i), f"{ts(st)} --> {ts(en)}", text, ""]
          open("subs.srt","w",encoding="utf-8").write("\n".join(lines))
          PY

      - name: Build BG schedule from bg_switch_at + bg_urls
        env:
          AUDIO_DUR: ${{ steps.dur.outputs.duration }}
        run: |
          python3 - << 'PY'
          import json, os
          total = float(os.environ.get("AUDIO_DUR","50"))
          if total < 1: total = 50.0
      - name: Decode payload
        run: |
          python - <<'PY'
          import os, json, base64, sys
          evt = json.load(open(os.environ['GITHUB_EVENT_PATH'], encoding='utf-8'))
          open('segments.json','w',encoding='utf-8').write(
            base64.b64decode(evt['client_payload']['segments_b64']).decode('utf-8')
          )
          open('narration.txt','w',encoding='utf-8').write(
            base64.b64decode(evt['client_payload']['narration_b64']).decode('utf-8')
          )
          PY

