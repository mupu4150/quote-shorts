name: build-shorts-b64

on:
  repository_dispatch:
    types: [quote-shorts]
  # 手動テスト用（payload空でも最後まで動くようフォールバック付き）
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            ffmpeg jq python3 python3-pip \
            open-jtalk open-jtalk-mecab-naist-jdic \
            hts-voice-nitech-jp-atr503-m001 \
            fonts-noto-cjk

      # OpenJTalk の辞書と音声ファイルの実パスを検出
      - name: Resolve OpenJTalk paths
        id: jtalk
        run: |
          DIC=$(dpkg -L open-jtalk-mecab-naist-jdic | grep '/naist-jdic$' | head -n1)
          VOICE=$(dpkg -L hts-voice-nitech-jp-atr503-m001 | grep '\.htsvoice$' | head -n1)
          echo "dic=$DIC"   >> $GITHUB_OUTPUT
          echo "voice=$VOICE" >> $GITHUB_OUTPUT
          test -n "$DIC" -a -n "$VOICE" || (echo "OpenJTalk dic/voice not found"; exit 1)

      # ③ payload を読む部分（Base64 を復元してファイルに）
      - name: Decode payload (Base64 → files)
        run: |
          python3 - <<'PY'
          import os, json, base64, sys, textwrap

          ev = json.load(open(os.environ['GITHUB_EVENT_PATH'], encoding='utf-8'))
          cp = ev.get('client_payload', {})

          def b64get(key, default=""):
            v = cp.get(key)
            if not v:
              return default
            try:
              return base64.b64decode(v).decode('utf-8')
            except Exception:
              return default

          # 受け取り（無ければフォールバック）
          segs_json = b64get('segments_b64', '')
          narr      = b64get('narration_b64', '')
          rate      = cp.get('voice_rate', 1.08)
          bg_switch = cp.get('bg_switch_at', [])
          bg_urls   = cp.get('bg_urls', [])

          # フォールバック（手動Runなど、payloadが空の時向け）
          if not segs_json:
            segs_json = json.dumps([{"text": "テスト字幕です。これは同期確認用のサンプルです。"}], ensure_ascii=False)
          if not narr:
            narr = "テスト音声です。これは同期確認用のサンプルです。"

          # 出力ファイル
          open('segments.json','w',encoding='utf-8').write(segs_json)
          open('narration.txt','w',encoding='utf-8').write(narr)
          json.dump({"bg_switch_at": bg_switch, "bg_urls": bg_urls}, open('bg.json','w',encoding='utf-8'))
          open('rate.txt','w',encoding='utf-8').write(str(rate))
          PY
          echo "VOICE_RATE=$(cat rate.txt)" >> $GITHUB_ENV

      - name: TTS (OpenJTalk → voice.wav)
        env:
          DIC: ${{ steps.jtalk.outputs.dic }}
          VOICE: ${{ steps.jtalk.outputs.voice }}
          RATE: ${{ env.VOICE_RATE }}
        run: |
          # 念のため空ファイル対策
          [ -s narration.txt ] || echo "テスト音声です。これは同期確認用のサンプルです。" > narration.txt
          open_jtalk -x "$DIC" -m "$VOICE" -r "${RATE:-1.08}" -ow voice.wav < narration.txt

      - name: Measure audio duration
        id: dur
        run: |
          D=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 voice.wav)
          printf "duration=%.3f\n" "$D" >> $GITHUB_OUTPUT

      - name: Build SRT aligned to audio (proportional)
        env:
          AUDIO_DUR: ${{ steps.dur.outputs.duration }}
        run: |
          python3 - <<'PY'
          import json, os

          total = float(os.environ.get("AUDIO_DUR","50") or 50)
          if total < 5: total = 50.0

          # segments.json は ["text", ...] でも [{"text":"..."}, ...] でもOKにする
          raw = json.load(open("segments.json","r",encoding="utf-8"))
          segs=[]
          if isinstance(raw, list):
            for it in raw:
              if isinstance(it, str):
                text = it.strip()
              elif isinstance(it, dict):
                text = str(it.get("text") or it.get("line") or it.get("content") or "").strip()
              else:
                text=""
              if text:
                segs.append(text)
          else:
            segs = [str(raw).strip()] if raw else []

          if not segs:
            segs = ["テスト字幕です。これは同期確認用のサンプルです。"]

          def weight(t): return max(1, len("".join(ch for ch in t if ch.strip())))
          W = [weight(t) for t in segs]
          S = sum(W) or 1
          lens = [total*w/S for w in W]

          starts=[0.0]
          for L in lens[:-1]:
            starts.append(starts[-1]+L)

          def ts(x):
            x=max(0.0,x)
            h=int(x//3600); m=int((x%3600)//60); s=int(x%60); ms=int((x*1000)%1000)
            return f"{h:02d}:{m:02d}:{s:02d},{ms:03d}"

          lines=[]
          for i, text in enumerate(segs,1):
            st=starts[i-1]; en=(starts[i] if i<len(starts) else total)
            lines += [str(i), f"{ts(st)} --> {ts(en)}", text, ""]
          open("subs.srt","w",encoding="utf-8").write("\n".join(lines))
          PY

      - name: Build BG schedule from bg.json
        env:
          AUDIO_DUR: ${{ steps.dur.outputs.duration }}
        run: |
          python3 - <<'PY'
          import json, os
          total = float(os.environ.get("AUDIO_DUR","50") or 50)
          if total < 1: total = 50.0
          cfg = json.load(open("bg.json","r",encoding="utf-8"))
          pts = cfg.get("bg_switch_at") or []
          urls = [u for u in (cfg.get("bg_urls") or []) if isinstance(u,str) and u.strip()]

          # デフォルトURL
          if not urls:
            urls = ["https://picsum.photos/1080/1920"]

          # スイッチ時刻が無ければ、URL数で等分
          if not pts:
            step = total / max(1, len(urls))
            pts = [round(step*i, 3) for i in range(len(urls))]
            pts.append(total)

          # 0と合計を包含してクリーンアップ
          pts = sorted(set([0.0] + [float(p) for p in pts if isinstance(p,(int,float,str)) and float(p)>=0] + [total]))
          # windows的重複でゼロ長が出ないように
          pts = [p for i,p in enumerate(pts) if i==0 or p>pts[i-1]]

          sched=[]
          for i in range(len(pts)-1):
            sched.append({"url": urls[i % len(urls)], "start": pts[i], "end": pts[i+1]})
          json.dump(sched, open("bg_sched.json","w",encoding="utf-8"), ensure_ascii=False, indent=2)
          PY

      - name: Download BG images & make concat list
        run: |
          python3 - <<'PY'
          import json, urllib.request
          sched = json.load(open("bg_sched.json","r",encoding="utf-8"))
          lines=[]
          lastfile = None
          for i, it in enumerate(sched,1):
            out=f"bg{i}.jpg"
            try:
              urllib.request.urlretrieve(it["url"], out)
            except Exception:
              urllib.request.urlretrieve("https://picsum.photos/1080/1920", out)
            dur = max(0.2, float(it["end"])-float(it["start"]))
            lines.append(f"file {out}\n")
            lines.append(f"duration {dur}\n")
            lastfile = out
          if lastfile:
            lines.append(f"file {lastfile}\n")  # concat demuxer末尾対策
          open("bglist.txt","w",encoding="utf-8").writelines(lines)
          PY

      - name: Build BG slideshow
        run: |
          ffmpeg -y -f concat -safe 0 -i bglist.txt \
            -vf "scale=1080:1920:force_original_aspect_ratio=cover,fps=30,format=yuv420p" \
            -pix_fmt yuv420p bg.mp4

      - name: Compose final (subtitles + TTS)
        run: |
          ffmpeg -y -i bg.mp4 -i voice.wav \
            -vf "subtitles=subs.srt:force_style='FontName=Noto Sans CJK JP,Fontsize=42,Outline=3,Shadow=0'" \
            -c:v libx264 -pix_fmt yuv420p -r 30 -c:a aac -shortest short.mp4

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: short-${{ github.run_id }}
          path: short.mp4
          retention-days: 7
